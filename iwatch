#!/usr/bin/perl
# iWatch
# By Cahya Wirawan <cahya at gmx dot at>
# Usage in daemon mode: 
# iwatch [-f <configfile.xml>] [-d] [-v]
# Usage in command line mode:
# iwatch [-c command] [-e event[,event[,..]]] [-m email] [-r] [-w target] [-x exception]
# iWatch monitor any changes in directories/files specified
# in the configuration file, and send email alert.
# This program needs inotify in linux kernel >= 2.6.13  

use strict;
use Getopt::Std;
use Event;
use Linux::Inotify2;
use File::Find;
use Mail::Sendmail;
use Sys::Hostname;
use XML::Simple;
use POSIX;
#use Data::Dumper;

my $PROGRAM = "iWatch";
my $VERSION = "0.0.6";
my $DEBUG = 0;
my $CONFIGFILE = "/etc/iwatch.xml";
my $config;
my %WatchList;
my %Mail;
my %Events;
my $Filename;
sub Usage;
sub wanted;
sub mywatch;
sub pathwatch;
sub getMask;
sub stringf;

my %options=();
my %formats = (
  'p' => sub { $PROGRAM },
  'v' => sub { $VERSION },
  'f' => sub { $Filename }
);
my %InotifyEvents = (
  'access' => IN_ACCESS,
  'modify' => IN_MODIFY,
  'attrib' => IN_ATTRIB,
  'close_write' => IN_CLOSE_WRITE,
  'close_nowrite' => IN_CLOSE_NOWRITE,
  'open' => IN_OPEN,
  'moved_from' => IN_MOVED_FROM,
  'moved_to' => IN_MOVED_TO,
  'create' => IN_CREATE,
  'delete' => IN_DELETE,
  'delete_self' => IN_DELETE_SELF,
  'move_self' => IN_MOVE_SELF,
  'unmount' => IN_UNMOUNT,
  'q_overflow' => IN_Q_OVERFLOW,
  'ignored' => IN_IGNORED,
  'close' => IN_CLOSE,
  'move' => IN_MOVE,
  'isdir' => IN_ISDIR,
  'oneshot' => IN_ONESHOT,
  'all_events' => IN_ALL_EVENTS,
  'default' => IN_CLOSE_WRITE|IN_CREATE|IN_DELETE|IN_MOVE|IN_DELETE_SELF|IN_MOVE_SELF,
);
my %InotifyEventNames;
foreach my $EventName (keys %InotifyEvents) {
  $InotifyEventNames{$InotifyEvents{$EventName}} = "IN_\U$EventName";
}

my $opt = getopts("vhdf:c:e:m:rw:x:",\%options);

if(defined $options{h} || $opt == 0) {
  Usage();
  exit 1;
}

$CONFIGFILE = $options{f} if(defined $options{f});
$DEBUG = 1 if defined $options{v};
delete @ENV{qw(ENV IFS CDPATH)};
$ENV{PATH} = "/bin:/usr/bin:/usr/sbin";

if((defined $options{f} || defined $options{d} || defined $options{F}) && 
   (defined $options{c} || defined $options{e} || defined $options{m} 
     || defined $options{r} || defined $options{w} || defined $options{x})) {
     print STDERR "Options [f|d] and [c|e|m|r|w|x] are mutually exlusive, you can't mix it!\n";
     Usage();
     exit 1;
   }

if(defined $options{w}) {
  $DEBUG = 1;
  $config->{guard}->{email} = (getpwuid($>))[0] . "\@localhost";
  $config->{watchlist}[0]->{path}[0]->{content} = $options{w};
  $config->{watchlist}[0]->{path}[0]->{events} = 
    (defined $options{e}) ? $options{e} : "default";
  $config->{watchlist}[0]->{path}[0]->{type} = 
    (defined $options{r}) ? "recursive" : "single";
  if(defined $options{c}) {
  	$config->{watchlist}[0]->{path}[0]->{exec} = $options{c};
  }
  if(defined $options{m}) {
  	$config->{watchlist}[0]->{path}[0]->{alert} = "on";
  	$config->{watchlist}[0]->{contactpoint}->{email} = $options{m};
  }
  else {
  	$config->{watchlist}[0]->{path}[0]->{alert} = "off";
  }
  if(defined $options{x}) {
    $config->{watchlist}[0]->{path}[1]->{content} = $options{x};
    $config->{watchlist}[0]->{path}[1]->{type} = "exception";
  }
}
else {
  if(! -f $CONFIGFILE) {
    Usage();
  	exit 1;
  }
  $config = XMLin($CONFIGFILE, ForceArray => ['path','watchlist']);
}

#print Dumper($config);

if(defined $options{d}) {
  my $ChildPid = fork;
  die "Can't fork: $!\n" if(!defined $ChildPid);
  exit if($ChildPid);

  POSIX::setsid() or die "Can't start a new session: $!";
  open STDIN, "</dev/null";
  open STDOUT, ">/dev/null";
  open STDERR, ">&STDOUT";
  umask 0;
  chdir "/";
}

my $inotify = new Linux::Inotify2;
Event->io (fd => $inotify->fileno, poll => 'r', cb => sub { $inotify->poll });

foreach my $watchpoint (@{$config->{watchlist}}) {
  foreach my $path (@{$watchpoint->{path}}) {
    next if($path->{type} ne "exception");
  	if(-d $path->{content}) { $path->{content} =~ s/\/$//;};
  	$WatchList{$path->{type}}{$path->{content}}{"type"} =  $path->{type};
  }
}

foreach my $watchpoint (@{$config->{watchlist}}) {
  foreach my $path (@{$watchpoint->{path}}) {
  	next if($path->{type} eq "exception");
  	if(-d $path->{content}) { $path->{content} =~ s/\/$//;};
    $WatchList{$path->{type}}{$path->{content}}{"contactpoint"} = $watchpoint->{contactpoint}->{email};
    $WatchList{$path->{type}}{$path->{content}}{"exec"} = $path->{exec} if(defined($path->{exec}));
    $WatchList{$path->{type}}{$path->{content}}{"alert"} = 
      (defined($path->{alert}) && $path->{alert} eq "off") ? 0:1;
    $WatchList{$path->{type}}{$path->{content}}{"type"} =  $path->{type};

    our $mask;
    if(!defined($path->{'events'})) {
      $mask = $InotifyEvents{'default'}; 
    }
    else {
      $mask = getMask($path->{'events'});
      $mask = $mask | $InotifyEvents{'create'} if($path->{type} eq "recursive");
    }
    $WatchList{$path->{type}}{$path->{content}}{"mask"} = $mask;
    pathwatch($path->{type},$path->{content});
  }
}

$Mail{From} = $config->{guard}->{email};

Event::loop;

sub getMask {
  my ($events) = @_;
  my $mask = 0;
  foreach my $event ( split(',',$events)) {
    $event =~ s/\s//g;
    warn "Event $event doesn't not exist!" if (!defined($InotifyEvents{$event}));
    $mask = $mask | $InotifyEvents{$event};
  }
  return $mask;
}

sub pathwatch {
  our $mask;
  my ($mode,$path) = @_;
  if(-e "$path") {
    if($mode eq "single") {
      print "Watch $path\n" if($DEBUG);
      $inotify->watch ("$path", $mask, \&mywatch);
    }
    elsif($mode eq "recursive") {
      File::Find::find({wanted => \&wanted}, "$path");
    }
  }
}

sub wanted {
  our $mask;
  if(-d $File::Find::name) {
  	return if(!defined(getWatchList($File::Find::name)));
    print "Watch $File::Find::name\n" if($DEBUG);
    $inotify->watch ("$File::Find::name", $mask, \&mywatch);
  }
}

sub getWatchList {
  my ($path) = @_;
  return undef if($WatchList{"exception"}{$path});
  foreach my $key (keys %{$WatchList{"exception"}}) {
    return undef if("$path" =~ /^$key/);
  }
  return $WatchList{"single"}{$path} if(defined $WatchList{"single"}{$path});
  return $WatchList{"recursive"}{$path} if(defined $WatchList{"recursive"}{$path});
  foreach my $key (keys %{$WatchList{"recursive"}}) {
    return $WatchList{"recursive"}{$key} if($path =~ /^$key/);
  }
  return undef;
}

sub mywatch {
  my $e = shift;
  my $Message;
  my $localMessage;
  $Filename = $e->fullname;
  return if(defined $WatchList{"exception"}{$Filename});
  my $Path = getWatchList($e->{w}->{name});
  return if(!defined($Path));
  
  if($DEBUG) {
  	my $mask = $e->mask;
  	if($e->IN_ISDIR) { $mask = ($e->mask ^ IN_ISDIR); $Message = "IN_ISDIR";}
  	if($e->IN_ONESHOT) { $mask = ($e->mask ^ IN_ONESHOT); $Message = "IN_ONESHOT";}
	$Message = (defined $Message) ? "$Message,$InotifyEventNames{$mask} $Filename" : 
	  "$InotifyEventNames{$mask} $Filename";
  	print "$Message\n";
  	$Mail{Subject} = "[$PROGRAM] " . hostname() . ": $InotifyEventNames{$mask} $Filename";  
  }

  if($e->IN_CREATE && -d $Filename && $Path->{'type'} eq "recursive") {
    print STDERR "* Directory $Filename is watched\n" if($DEBUG);
    $inotify->watch ($Filename, $Path->{'mask'}, \&mywatch);
  }
  elsif($e->IN_CLOSE_WRITE && -f $Filename) {
  	$localMessage = "* $Filename is closed\n";
    $Message = "$Message\n$localMessage";
    $Mail{Subject} = "[$PROGRAM] " . hostname() . ": $Filename is changed";  
    print STDERR $localMessage if($DEBUG);
  }
  elsif($e->IN_DELETE) {
    $localMessage = "* $Filename is deleted\n";
    $Message = "$Message\n$localMessage";
    $Mail{Subject} = "[$PROGRAM] " . hostname() . ": $Filename is deleted";  
    print STDERR $localMessage if($DEBUG);
  }
  elsif($e->IN_MOVED_FROM || $e->IN_MOVED_TO) {
    if($e->IN_MOVED_FROM) {
      $Events{$e->{cookie}} = "$Filename";
    }
    elsif($e->IN_MOVED_TO) {
      my $FileMove = $Events{$e->{cookie}} . ":$Filename";
      
      $localMessage = "* $Events{$e->{cookie}} is moved to $Filename\n";
      $Message = "$Message\n$localMessage";
      $Mail{Subject} = "[$PROGRAM] " . hostname() . ": $Events{$e->{cookie}} is moved to $Filename";  
      print STDERR $localMessage if($DEBUG);
      undef $Events{$e->{cookie}};
    }
  }
  elsif($e->IN_DELETE_SELF && -f $Filename && defined $WatchList{$Filename}) {
  	
  	$localMessage = "* $Filename is replaced but watched again\n";
    $Message = "$Message\n$localMessage";
    $Mail{Subject} = "[$PROGRAM] " . hostname() . ": $Filename is replaced";  
    print STDERR $localMessage if($DEBUG);
    $inotify->watch ("$Filename", $Path->{'mask'}, \&mywatch);
  }
  if(defined($Path->{exec})) {
    my $command = stringf("$Path->{exec}",%formats);
    print STDERR "* Command: $command\n" if($DEBUG);
    system ("$command");
  }
  if(defined($Message) && $Path->{'alert'}) {
    $Mail{Message} = $Message;
    $Mail{To} = $Path->{'contactpoint'};
    print STDERR "* Send email to $Mail{To}\n" if($DEBUG);
    sendmail(%Mail) or warn $Mail::Sendmail::error;
  }
}

sub stringf() {
  my $ind;
  my ($string,%format) = @_;
  foreach my $key (keys %format) {
    $ind = index $string,"%$key";
    next if($ind == -1);
    substr($string,$ind,2) = &{$format{$key}};
    $string = stringf($string,%format);
  }
  $string;
}

sub Usage {
  print <<ENDOFHELP;
$PROGRAM $VERSION, a realtime filesystem monitor.
Cahya Wirawan <cahya at gmx dot at>, Vienna 2006.

In the daemon mode, $PROGRAM has following options:
Usage: iwatch [-d] [-f <config file>] [-v]
  -d Execute the application as daemon.
  -f Specify an alternate xml configuration file.
  -v verbose mode.

And in the command line mode:
Usage: iwatch [-c command] [-e event[,event[,..]]] [-m email] [-r] [-w target] [-x exception]
  -c You can specify a command to be executed if an event occurs.
  -e Events list.
  -m Contact point's email address.
  -r Recursivity of the watched directory.
  -w The watched directory
  -x The exception (file or directory).
ENDOFHELP
}
